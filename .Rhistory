install.packages("rpart.plot")
library(rpart.plot)
help(rpartXse)
ar <- rpartXse(dat ~ Beat + HourType, tr)
ar <- rpartXse(modelDat ~ Beat + HourType, tr)
ar <- rpartXse(X..offenses ~ Beat + HourType, tr)
ar
help(prp)
prp(ar,type=4,extra=101)
ar <- rpartXse(X..offenses ~ Beat + HourType, ts)
prp(ar,type=4,extra=101)
help(prp)
prp(ar,type=0,extra=101)
help(set.seed)
nb <- naiveBayes(modelDat ~ Beat + HourType, tr)
nb <- naiveBayes(X..offenses ~ Beat + HourType, tr)
nb
sp <- sample(1:nrow(modelDat), as.integer(nrow(modelDat)*0.7))
tr <- modelDat[sp,]
ts <- modelDat[-sp,]
nb <- naiveBayes(X..offenses ~ Beat + HourType, tr)
nb <- naiveBayes(N ~ Beat + HourType, tr)
nb
(mtrx <- table(predict(nb,ts),ts$N))
View(ts)
View(ts)
#Load the packages
library(gdata)
library(lubridate)
library(xts)
library(dplyr)
library(stringr)
library(DMwR)
library(class)
library(nnet)
library(e1071)
library(earth)
library(randomForest)
perldir <- Sys.which("perl")
fc <- "crime.xls"
dat <- read.xls(fc, sheet = 1, header = TRUE, verbose=FALSE, perl=perldir, na.strings = "UNK")
dat$BlockRange <- as.character(dat$BlockRange)
dat$StreetName <- as.character(dat$StreetName)
dat$Type <- as.character(dat$Type)
dat$Suffix <- as.character(dat$Suffix)
unique(dat$Offense.Type)
dat[dat$Offense.Type == 1,]
dat[!grep("^[0-9]{4}-[0-9]{2}-[0-9]{2}$", dat$Date),]
dat[dat$Hour < 0 | dat$Hour > 23,]
dat[!grep("^[0-9]{2}$", dat$Hour),]
unique(dat$Beat)
nrow(dat[is.na(dat$Beat),])
nrow(dat[is.na(dat$BlockRange),])
unique(dat$Type)
nrow(dat[dat$Type == "-",])
unique(dat$Suffix)
nrow(dat[dat$Suffix == "-",])
unique(dat$X..offenses)
load("gps.RData")
incomplete <- is.na(dat$Beat)
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
dat$Beat[incomplete] <- knn(tr, ts, dat$Beat[!incomplete], k = 3)
load("gps.RData")
incomplete <- is.na(dat$Beat)
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
dat$Beat[incomplete] <- knn(tr, ts, dat$Beat[!incomplete], k = 3)
incomplete <- is.na(dat$BlockRange)
dat$BlockRange[incomplete] <- centralValue(dat$BlockRange)
incomplete <- is.na(dat$Type)
dat$Type[incomplete] <- centralValue(dat$Type)
incomplete <- is.na(dat$Suffix)
#... see on GPS?
dat <- tbl_df(dat)
#View the data per hour
datxts <- xts(dat, ymd_h(paste(dat$Date,' ',dat$Hour)))
#Split the data into 3 categories
i1 <- filter(dat, 8 <= dat$Hour, dat$Hour < 12)
i2 <- filter(dat, 12 <= dat$Hour, dat$Hour < 19)
i3 <- filter(dat, (19 <= dat$Hour & dat$Hour <= 23) | (0 <= dat$Hour & dat$Hour < 8))
#How many Offenses are made per interval in each category
sum1 <- group_by(i1, Beat) %>% summarise(num=sum(X..offenses))
sum2 <- group_by(i2, Beat) %>% summarise(num=sum(X..offenses))
sum3 <- group_by(i3, Beat) %>% summarise(num=sum(X..offenses))
#How many offenses are made per offense type
sum4 <- group_by(dat, Offense.Type) %>% summarise(num=sum(X..offenses))
#How many offenses are made per offense type in each beat
sum5 <- group_by(dat, Offense.Type, Beat) %>% summarise(num=sum(X..offenses))
dat %>% summarise(avg.Off=mean(dat$X..offenses),
cen.OffTp=centralValue(dat$Offense.Type),
cen.StrNm=centralValue(dat$StreetName))
barplot(c(sum(sum1$num), sum(sum2$num), sum(sum3$num)), names.arg = c("8-12", "12-19", "19-8"), main = "Total crimes over time intervals")
beat <- group_by(dat, Beat) %>% summarise(num=sum(X..offenses))
most <- head(arrange(beat,desc(num)))
barplot(most$num, names.arg=most$Beat, main="Beats with most crimes")
least <- head(arrange(beat, num))
barplot(least$num, names.arg=least$Beat, main="Beats with least crimes")
boxplot(beat$num, main="Distribution of number of crimes per beat")
offenses <- group_by(dat, Offense.Type) %>%
filter(Offense.Type != 1) %>% summarize(total=sum(X..offenses))
barplot(offenses$total, names.arg=offenses$Offense.Type,
main="Number of occurences per crime type")
fiscalDate <- function(arg) {
date <- arg[2]
hour <- arg[1]
if (as.integer(hour) >= 0 && as.integer(hour) < 8)
return(as.character(ymd(date)-1));
return(as.character(ymd(date)));
}
#Identification of the time period
hourType <- function(hour) {
hour <- as.integer(hour)
if (8 <= hour && hour < 12)
return(1)
if (12 <= hour && hour < 19)
return(2)
return(3)
}
args <- mapply(c, dat$Hour, as.character(dat$Date), SIMPLIFY = FALSE)
dat <- mutate(dat, HourType=sapply(Hour, hourType))
dat <- mutate(dat, FiscalDate=sapply(args, fiscalDate))
##Descriptors: Beat and HourType
##Target variable: X..offenses
modelDat <- group_by(dat, FiscalDate, Beat, HourType) %>% summarize(N=sum(X..offenses))
library(e1071)
sp <- sample(1:nrow(modelDat), as.integer(nrow(modelDat)*0.7))
tr <- modelDat[sp,]
ts <- modelDat[-sp,]
nb <- naiveBayes(N ~ Beat + HourType, tr)
(mtrx <- table(predict(nb,ts),ts$N))
nb
ped <- predict(nb,ts)
pred <- predict(nb,ts)
View(ts)
View(ts)
pred
View(modelDat)
View(modelDat)
nrow(dat[is.na(modelDat$FiscalDate),])
nrow(dat[is.na(modelDat$Beat),])
nrow(dat[is.na(modelDat$HourType),])
nrow(dat[is.na(modelDat$N),])
nrow(modelDat[is.na(modelDat$N),])
nrow(modelDat[is.na(modelDat$FiscalDate),])
nrow(modelDat[is.na(modelDat$HourType),])
nrow(modelDat[is.na(modelDat$Beat),])
nrow(ts[is.na(ts$Beat),])
nrow(ts[is.na(ts$N),])
nrow(ts[is.na(ts$HourType),])
nrow(ts[is.na(ts$FiscalDate),])
pred <- predict(nb,ts)
pred <- predict(as.matrix(nb),as.matrix(ts))
help("as.data.frame")
pred <- predict(as.data.frame(nb),as.data.frame(ts))
pred <- predict(nb,as.data.frame(ts))
pred <- predict(nb,as.matrix(ts))
pred <- predict(nb, ts)
nb <- naiveBayes(N ~ Beat + HourType, tr, laplace=1)
nb
pred <- predict(nb, ts)
s <- svm(N ~ Beat + HourType,tr)
predict(s,ts)
s
s
predict()
pred(s,ts)
s <- svm(N ~ Beat + HourType,tr)
pred(s,ts)
pred <- predict(s,ts)
pred
ps <- predict(s,ts)
table(ps,ts$N)
mc <- table(ps,ts$N)
mc
(error <- 100*(1-sum(diag(mc))/sum(mc)))
s <- svm(N ~ Beat + HourType, tr, cost=10, epsilon=0.02)
s
pred <- predict(s,ts)
regr.eval(ts$N, pred)
plot(ts$N, pred, main='Errors Scaterplot', ylab='Predictions', xlab='True')
abline(0,1,col='red',lty=2)
help(factor)
preds_ <- predict(factor(nb_levels=levels(factor(ts$N))), ts)
library(nnet)
nn <- nnet(N ~ Beat + HourType, tr, size=8, decay=0.1, maxit=1000)
(mtrx <- table(predict(nn,ts,type='class'),ts$N))
help("predict")
help(predict)
(mtrx <- table(predict(nn,ts),ts$N))
nn
summary(nn)
nn
head(predict(nn,ts))
predict(nn,ts)
mars <- earth(N ~ Beat + HourType, tr)
mars
preds <- predict(mars,ts)
preds
summary(mars)
library(randomForest)
m <- randomForest(N ~ Beat + HourType, tr)
tr
m <- randomForest(N ~ Beat + HourType, tr)
help(randomForest)
m <- randomForest(N ~ Beat + HourType, tr)
m <- rpartXse(N ~ Beat + HourType,tr)
p <- predict(m,ts)
m
p
regr.eval(ts$N,p,train.y=tr$N)
setwd(dir)
getwd()
#Install the necessary packages
install.packages("gdata")
install.packages("lubridate")
install.packages("xts")
install.packages("dplyr")
install.packages("DMwR")
install.packages("e1071")
install.packages("earth")
install.packages("randomForest")
install.packages("performanceEstimation")
#Load the packages
library(gdata)
library(lubridate)
library(xts)
library(dplyr)
library(stringr)
library(DMwR)
library(class)
library(nnet)
library(e1071)
library(earth)
library(randomForest)
library(performanceEstimation)
perldir <- Sys.which("perl")
fc <- "crime.xls"
dat <- read.xls(fc, sheet = 1, header = TRUE, verbose=FALSE, perl=perldir, na.strings = "UNK")
dat$BlockRange <- as.character(dat$BlockRange)
dat$StreetName <- as.character(dat$StreetName)
dat$Type <- as.character(dat$Type)
dat$Suffix <- as.character(dat$Suffix)
unique(dat$Offense.Type)
dat[dat$Offense.Type == 1,]
dat[!grep("^[0-9]{4}-[0-9]{2}-[0-9]{2}$", dat$Date),]
dat[dat$Hour < 0 | dat$Hour > 23,]
dat[!grep("^[0-9]{2}$", dat$Hour),]
unique(dat$Beat)
nrow(dat[is.na(dat$Beat),])
nrow(dat[is.na(dat$BlockRange),])
unique(dat$Type)
nrow(dat[dat$Type == "-",])
unique(dat$Suffix)
nrow(dat[dat$Suffix == "-",])
unique(dat$X..offenses)
load("gps.RData")
incomplete <- is.na(dat$Beat)
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
dat$Beat[incomplete] <- knn(tr, ts, dat$Beat[!incomplete], k = 3)
incomplete <- is.na(dat$BlockRange)
dat$BlockRange[incomplete] <- centralValue(dat$BlockRange)
incomplete <- is.na(dat$Type)
dat$Type[incomplete] <- centralValue(dat$Type)
incomplete <- is.na(dat$Suffix)
#... see on GPS?
dat <- tbl_df(dat)
#View the data per hour
datxts <- xts(dat, ymd_h(paste(dat$Date,' ',dat$Hour)))
#Split the data into 3 categories
i1 <- filter(dat, 8 <= dat$Hour, dat$Hour < 12)
i2 <- filter(dat, 12 <= dat$Hour, dat$Hour < 19)
i3 <- filter(dat, (19 <= dat$Hour & dat$Hour <= 23) | (0 <= dat$Hour & dat$Hour < 8))
#How many Offenses are made per interval in each category
sum1 <- group_by(i1, Beat) %>% summarise(num=sum(X..offenses))
sum2 <- group_by(i2, Beat) %>% summarise(num=sum(X..offenses))
sum3 <- group_by(i3, Beat) %>% summarise(num=sum(X..offenses))
#How many offenses are made per offense type
sum4 <- group_by(dat, Offense.Type) %>% summarise(num=sum(X..offenses))
#How many offenses are made per offense type in each beat
sum5 <- group_by(dat, Offense.Type, Beat) %>% summarise(num=sum(X..offenses))
dat %>% summarise(avg.Off=mean(dat$X..offenses),
cen.OffTp=centralValue(dat$Offense.Type),
cen.StrNm=centralValue(dat$StreetName))
barplot(c(sum(sum1$num), sum(sum2$num), sum(sum3$num)), names.arg = c("8-12", "12-19", "19-8"), main = "Total crimes over time intervals")
beat <- group_by(dat, Beat) %>% summarise(num=sum(X..offenses))
most <- head(arrange(beat,desc(num)))
barplot(most$num, names.arg=most$Beat, main="Beats with most crimes")
least <- head(arrange(beat, num))
barplot(least$num, names.arg=least$Beat, main="Beats with least crimes")
boxplot(beat$num, main="Distribution of number of crimes per beat")
offenses <- group_by(dat, Offense.Type) %>%
filter(Offense.Type != 1) %>% summarize(total=sum(X..offenses))
barplot(offenses$total, names.arg=offenses$Offense.Type,
main="Number of occurences per crime type")
fiscalDate <- function(arg) {
date <- arg[2]
hour <- arg[1]
if (as.integer(hour) >= 0 && as.integer(hour) < 8)
return(as.character(ymd(date)-1));
return(as.character(ymd(date)));
}
#Identification of the time period
hourType <- function(hour) {
hour <- as.integer(hour)
if (8 <= hour && hour < 12)
return(1)
if (12 <= hour && hour < 19)
return(2)
return(3)
}
args <- mapply(c, dat$Hour, as.character(dat$Date), SIMPLIFY = FALSE)
dat <- mutate(dat, HourType=sapply(Hour, hourType))
dat <- mutate(dat, FiscalDate=sapply(args, fiscalDate))
##Descriptors: Beat and HourType
##Target variable: X..offenses
modelDat <- group_by(dat, FiscalDate, Beat, HourType) %>% summarize(N=sum(X..offenses))
nn <- nnet(N ~ Beat + HourType, modelDat, size=8, decay=0.1, maxit=1000)
nb <- naiveBayes(N ~ Beat + HourType, modelDat)
s <- svm(N ~ Beat + HourType, modelDat)
mars <- earth(N ~ Beat + HourType, modelDat)
#m <- randomForest(N ~ Beat + HourType, modelDat)
rpart <- rpartXse(N ~ Beat + HourType, modelDat)
nreps <- 10
scores <- list(nnet=vector("numeric",length=nreps),
naiveBayes=vector("numeric",length=nreps),
svm=vector("numeric",length=nreps),
earth=vector("numeric",length=nreps),
randomForest=vector("numeric",length=nreps),
rpartXse=vector("numeric",length=nreps))
n <- nrow(modelDat)
set.seed(1234)
for(i in 1:nreps) {
# random sample with replacement
sp <- sample(n,n,replace=TRUE)
# data splitting
tr <- modelDat[sp,]
ts <- modelDat[-sp,]
# model learning and prediction
m <- nnet(N ~ Beat + HourType,tr, size=8, decay=0.1, maxit=1000)
p <- predict(m,ts)
# evaluation
scores$nnet[i] <- mean((ts$N-p)^2)
#m <- naiveBayes(N ~ Beat + HourType,tr)
#p <- predict(m,ts)
#scores$naiveBayes[i] <- mean((ts$N-p)^2)
m <- svm(N ~ Beat + HourType,tr)
p <- predict(m,ts)
scores$svm[i] <- mean((ts$N-p)^2)
m <- earth(N ~ Beat + HourType,tr)
p <- predict(m,ts)
scores$earth[i] <- mean(abs(ts$N-p)^2)
#m <- randomForest(N ~ Beat + HourType,tr)
#p <- predict(m,ts)
#scores$randomForest[i] <- mean((ts$N-p)^2)
m <- rpartXse(N ~ Beat + HourType,tr)
p <- predict(m,ts)
scores$rpartXse[i] <- mean((ts$N-p)^2)
}
# calculating means and standard errors
#summary(scores$naiveBayes)
summary(scores$nnet)
summary(scores$svm)
summary(scores$earth)
#summary(scores$randomForest)
summary(scores$rpartXse)
res <- performanceEstimation(PredTask(N ~ Beat + HourType, modelDat, "w/o"), workflowVariants(learner=c("svm", "earth", "rpartXse")), EstimationTask(metrics = c("mse", "mae")))
plot(res)
#Mean Squared Error
#mse <- mean((trueVals-preds)^2)
#Root Mean Squared Error
#rmse <- sqrt(mse)
#Mean Absolute Error
#mae <- mean(abs(trueVals-preds))
#Normalized Mean Squared Error
#nmse <- sum((trueVals-preds)^2) / sum((trueVals-mean(trueVals))^2)
#Normalized Mean Absolute Error
#nmae <- sum(abs(trueVals-preds)) / sum(abs(trueVals-mean(trueVals)))
#Mean Average Percentage Error
#mape <- mean(abs(trueVals-preds)/trueVals)
#Correlation between the predictions and the true values
#corr <- cor(trueVals,preds)
View(dat)
View(dat)
View(gps)
View(gps)
help(knn)
incomplete <- is.na(dat$Suffix)
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
dat$Suffix[incomplete] <- knn(tr, ts, dat$Suffix[!incomplete], k = 3)
View(dat)
View(dat)
nrow(dat[is.na(dat$Beat),])
nrow(dat[dat$Suffix == "-",])
incomplete
incomplete <- is.na(dat$Suffix)
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
dat$Suffix[incomplete] <- knn(tr, ts, dat$Suffix[!incomplete], k = 3)
View(dat)
View(dat)
dat$Suffix[incomplete] <- knn(tr, ts, dat$Suffix[!incomplete], k = 5)
nrow(dat[dat$Suffix == "-",])
View(dat)
View(dat)
incomplete <- is.na(dat$Suffix)
tr <- dat[!incomplete]
tr <- dat$Suffix[!incomplete]
ts <- dat$Suffix[incomplete]
tr
ts
incomplete <- dat[dat$Suffix == "-",]
tr <- gps[!incomplete,1:2]
incomplete
incomplete <- (dat$Suffix == "-")
incomplete
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
dat$Suffix[incomplete] <- knn(tr, ts, dat$Suffix[!incomplete], k = 3)
View(dat)
View(dat)
tr <- dat[!incomplete]
tr <- dat$Suffix[!incomplete]
ts <- dat$Suffix[incomplete]
tr
ts
dat$Suffix[incomplete] <- knn(tr, ts, dat$Suffix[!incomplete], k = 3)
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
tr
ts
dat$Suffix[incomplete] <- knn(tr, ts, dat$Suffix[!incomplete], k = 3)
View(dat)
View(dat)
unique(dat$Suffix)
#Load the packages
library(gdata)
library(lubridate)
library(xts)
library(dplyr)
library(stringr)
library(DMwR)
library(class)
library(nnet)
library(e1071)
library(earth)
library(randomForest)
library(performanceEstimation)
perldir <- Sys.which("perl")
fc <- "crime.xls"
dat <- read.xls(fc, sheet = 1, header = TRUE, verbose=FALSE, perl=perldir, na.strings = "UNK")
dat$BlockRange <- as.character(dat$BlockRange)
dat$StreetName <- as.character(dat$StreetName)
dat$Type <- as.character(dat$Type)
dat$Suffix <- as.character(dat$Suffix)
unique(dat$Offense.Type)
dat[dat$Offense.Type == 1,]
dat[!grep("^[0-9]{4}-[0-9]{2}-[0-9]{2}$", dat$Date),]
dat[dat$Hour < 0 | dat$Hour > 23,]
dat[!grep("^[0-9]{2}$", dat$Hour),]
nrow(dat[is.na(dat$BlockRange),])
unique(dat$Type)
nrow(dat[dat$Type == "-",])
unique(dat$Suffix)
nrow(dat[dat$Suffix == "-",])
unique(dat$X..offenses)
load("gps.RData")
incomplete <- is.na(dat$Beat)
incomplete
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
tr
ts
dat$Beat[incomplete] <- knn(tr, ts, dat$Beat[!incomplete], k = 3)
unique(dat$Beat)
nrow(dat[is.na(dat$Beat),])
incomplete <- is.na(dat$BlockRange)
dat$BlockRange[incomplete] <- centralValue(dat$BlockRange)
nrow(dat[is.na(dat$BlockRange),])
incomplete <- is.na(dat$Type)
dat$Type[incomplete] <- centralValue(dat$Type)
nrow(dat[dat$Type == "-",])
incomplete <- (at$Type == "-")
incomplete <- (dat$Type == "-")
dat$Type[incomplete] <- centralValue(dat$Type)
nrow(dat[dat$Type == "-",])
incomplete
dat$Type[incomplete] <- centralValue(dat$Type)
nrow(dat[dat$Type == "-",])
View(dat)
View(dat)
centralValue(dat$Type)
centralValue(dat$Type[!incomplete])
dat$Type[incomplete] <- centralValue(dat$Type[!incomplete])
nrow(dat[dat$Type == "-",])
incomplete <- (dat$Suffix == "-")
#... see on GPS?
tr <- gps[!incomplete,1:2]
ts <- gps[incomplete,1:2]
dat$Suffix[incomplete] <- knn(tr, ts, dat$Suffix[!incomplete], k = 3)
knn(tr, ts, dat$Suffix[!incomplete], k = 3)
is.character(knn(tr, ts, dat$Suffix[!incomplete], k = 3))
character(knn(tr, ts, dat$Suffix[!incomplete], k = 3))
as.character(knn(tr, ts, dat$Suffix[!incomplete], k = 3))
dat$Suffix[incomplete] <- is.character(knn(tr, ts, dat$Suffix[!incomplete], k = 3))
dat$Suffix[incomplete] <- as.character(knn(tr, ts, dat$Suffix[!incomplete], k = 3))
dat$Suffix[incomplete] <- as.character(knn(tr, ts, dat$Suffix[!incomplete], k = 5))
View(dat)
View(dat)
dat$Suffix[incomplete] <- as.character(knn(tr, ts, dat$Suffix[!incomplete], k = 3))
